/**
 * NAEB Report Service
 * Handles NAEB report generation and management
 */

import prisma from '../config/database';
import { NotFoundError, ValidationError } from '../utils/errors';
import { normalizePagination, createPaginationResult, PaginationResult } from '../utils/pagination';
import { parseDate } from '../utils/date';

type ReportType = 'monthly_summary' | 'quarterly_export' | 'annual_statistics' | 'quality_report' | 'payment_report' | 'custom';
type ReportStatus = 'draft' | 'submitted' | 'approved' | 'rejected';

export interface CreateReportData {
  reportType: ReportType;
  periodStart: string | Date;
  periodEnd: string | Date;
  generatedBy: string;
  data: Record<string, unknown>;
  status?: ReportStatus;
}

export interface UpdateReportData {
  reportType?: ReportType;
  periodStart?: string | Date;
  periodEnd?: string | Date;
  data?: Record<string, unknown>;
  status?: ReportStatus;
}

/**
 * Create a new NAEB report
 */
export const createReport = async (data: CreateReportData) => {
  if (!data.generatedBy) {
    throw new ValidationError('Generated by user ID is required');
  }

  // Validate generator exists and is admin
  const generator = await prisma.user.findUnique({
    where: { id: data.generatedBy },
  });

  if (!generator) {
    throw new NotFoundError('Generator user not found');
  }

  if (generator.role !== 'admin') {
    throw new ValidationError('Only admin users can create reports');
  }

  const periodStart = parseDate(data.periodStart);
  if (!periodStart) {
    throw new ValidationError('Valid period start date is required');
  }

  const periodEnd = parseDate(data.periodEnd);
  if (!periodEnd) {
    throw new ValidationError('Valid period end date is required');
  }

  // Validate period end is after period start
  if (periodEnd < periodStart) {
    throw new ValidationError('Period end date must be after period start date');
  }

  // Validate data is an object
  if (!data.data || typeof data.data !== 'object' || Array.isArray(data.data)) {
    throw new ValidationError('Report data must be a valid object');
  }

  const report = await prisma.nAEBReport.create({
    data: {
      reportType: data.reportType,
      periodStart,
      periodEnd,
      generatedBy: data.generatedBy,
      data: data.data as any,
      status: data.status || 'draft',
    },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
        },
      },
    },
  });

  return report;
};

/**
 * Get report by ID
 */
export const getReportById = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
        },
      },
    },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  return report;
};

/**
 * List reports with pagination and filters
 */
export const listReports = async (
  page: number = 1,
  limit: number = 10,
  reportType?: ReportType,
  status?: ReportStatus,
  generatedBy?: string
): Promise<PaginationResult<unknown>> => {
  const pagination = normalizePagination(page, limit, 1, 10, 100);
  const skip = (pagination.page - 1) * pagination.limit;

  const where: Record<string, unknown> = {};

  if (reportType) {
    where.reportType = reportType;
  }

  if (status) {
    where.status = status;
  }

  if (generatedBy) {
    where.generatedBy = generatedBy;
  }

  const [reports, total] = await Promise.all([
    prisma.nAEBReport.findMany({
      where,
      skip,
      take: pagination.limit,
      orderBy: {
        createdAt: 'desc',
      },
      include: {
        generatedByUser: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    }),
    prisma.nAEBReport.count({ where }),
  ]);

  return createPaginationResult(reports, total, pagination.page, pagination.limit);
};

/**
 * Update report
 */
export const updateReport = async (id: string, data: UpdateReportData) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const existing = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!existing) {
    throw new NotFoundError('Report not found');
  }

  // Cannot update submitted or approved reports
  if (existing.status === 'submitted' || existing.status === 'approved') {
    throw new ValidationError('Cannot update submitted or approved reports');
  }

  const updateData: Record<string, unknown> = {
    updatedAt: new Date(),
  };

  if (data.reportType !== undefined) {
    updateData.reportType = data.reportType;
  }

  if (data.periodStart !== undefined) {
    const periodStart = parseDate(data.periodStart);
    if (!periodStart) {
      throw new ValidationError('Valid period start date is required');
    }
    updateData.periodStart = periodStart;
  }

  if (data.periodEnd !== undefined) {
    const periodEnd = parseDate(data.periodEnd);
    if (!periodEnd) {
      throw new ValidationError('Valid period end date is required');
    }
    
    const periodStart = data.periodStart ? parseDate(data.periodStart) : existing.periodStart;
    if (!periodStart) {
      throw new ValidationError('Period start date is required for validation');
    }
    if (periodEnd < periodStart) {
      throw new ValidationError('Period end date must be after period start date');
    }
    
    updateData.periodEnd = periodEnd;
  }

  if (data.data !== undefined) {
    if (!data.data || typeof data.data !== 'object' || Array.isArray(data.data)) {
      throw new ValidationError('Report data must be a valid object');
    }
    updateData.data = data.data;
  }

  if (data.status !== undefined) {
    updateData.status = data.status;
    
    // If status is submitted, set submittedAt
    if (data.status === 'submitted' && !existing.submittedAt) {
      updateData.submittedAt = new Date();
    }
  }

  const report = await prisma.nAEBReport.update({
    where: { id },
    data: updateData,
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
        },
      },
    },
  });

  return report;
};

/**
 * Submit report
 */
export const submitReport = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  if (report.status !== 'draft') {
    throw new ValidationError('Only draft reports can be submitted');
  }

  const updated = await prisma.nAEBReport.update({
    where: { id },
    data: {
      status: 'submitted',
      submittedAt: new Date(),
    },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return updated;
};

/**
 * Approve report
 */
export const approveReport = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  if (report.status !== 'submitted') {
    throw new ValidationError('Only submitted reports can be approved');
  }

  const updated = await prisma.nAEBReport.update({
    where: { id },
    data: {
      status: 'approved',
    },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return updated;
};

/**
 * Reject report
 */
export const rejectReport = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  if (report.status !== 'submitted') {
    throw new ValidationError('Only submitted reports can be rejected');
  }

  const updated = await prisma.nAEBReport.update({
    where: { id },
    data: {
      status: 'rejected',
    },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return updated;
};

/**
 * Delete report
 */
export const deleteReport = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  // Cannot delete submitted or approved reports
  if (report.status === 'submitted' || report.status === 'approved') {
    throw new ValidationError('Cannot delete submitted or approved reports');
  }

  await prisma.nAEBReport.delete({
    where: { id },
  });

  return { message: 'Report deleted successfully' };
};

