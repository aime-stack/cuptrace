/**
 * NAEB Report Service
 * Handles NAEB report generation and management
 */

import prisma from '../config/database.js';
import { NotFoundError, ValidationError } from '../utils/errors.js';
import { normalizePagination, createPaginationResult, PaginationResult } from '../utils/pagination.js';
import { parseDate } from '../utils/date.js';

type ReportType = 'monthly_summary' | 'quarterly_export' | 'annual_statistics' | 'quality_report' | 'payment_report' | 'custom';
type ReportStatus = 'draft' | 'submitted' | 'approved' | 'rejected';

export interface CreateReportData {
  reportType: ReportType;
  periodStart: string | Date;
  periodEnd: string | Date;
  generatedBy: string;
  data: Record<string, unknown>;
  status?: ReportStatus;
}

export interface UpdateReportData {
  reportType?: ReportType;
  periodStart?: string | Date;
  periodEnd?: string | Date;
  data?: Record<string, unknown>;
  status?: ReportStatus;
}

export interface NaebReportParams {
  periodStart?: string;
  periodEnd?: string;
  reportType?: ReportType;
  format?: 'json' | 'pdf' | 'excel';
}

/**
 * Create a new NAEB report
 */
export const createReport = async (data: CreateReportData) => {
  if (!data.generatedBy) {
    throw new ValidationError('Generated by user ID is required');
  }

  // Validate generator exists and is admin
  const generator = await prisma.user.findUnique({
    where: { id: data.generatedBy },
  });

  if (!generator) {
    throw new NotFoundError('Generator user not found');
  }

  if (generator.role !== 'admin') {
    throw new ValidationError('Only admin users can create reports');
  }

  const periodStart = parseDate(data.periodStart);
  if (!periodStart) {
    throw new ValidationError('Valid period start date is required');
  }

  const periodEnd = parseDate(data.periodEnd);
  if (!periodEnd) {
    throw new ValidationError('Valid period end date is required');
  }

  // Validate period end is after period start
  if (periodEnd < periodStart) {
    throw new ValidationError('Period end date must be after period start date');
  }

  // Validate data is an object
  if (!data.data || typeof data.data !== 'object' || Array.isArray(data.data)) {
    throw new ValidationError('Report data must be a valid object');
  }

  // Auto-generate report data if empty
  let reportData = data.data;
  if (Object.keys(reportData).length === 0) {
    reportData = await generateNaebReport({
      periodStart: data.periodStart instanceof Date ? data.periodStart.toISOString() : data.periodStart,
      periodEnd: data.periodEnd instanceof Date ? data.periodEnd.toISOString() : data.periodEnd,
      reportType: data.reportType,
    });
  }

  const report = await prisma.nAEBReport.create({
    data: {
      reportType: data.reportType,
      periodStart,
      periodEnd,
      generatedBy: data.generatedBy,
      data: reportData as any,
      status: data.status || 'draft',
    },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
        },
      },
    },
  });

  return report;
};

/**
 * Get report by ID
 */
export const getReportById = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
        },
      },
    },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  return report;
};

/**
 * List reports with pagination and filters
 */
export const listReports = async (
  page: number = 1,
  limit: number = 10,
  reportType?: ReportType,
  status?: ReportStatus,
  generatedBy?: string
): Promise<PaginationResult<unknown>> => {
  const pagination = normalizePagination(page, limit, 1, 10, 100);
  const skip = (pagination.page - 1) * pagination.limit;

  const where: Record<string, unknown> = {};

  if (reportType) {
    where.reportType = reportType;
  }

  if (status) {
    where.status = status;
  }

  if (generatedBy) {
    where.generatedBy = generatedBy;
  }

  const [reports, total] = await Promise.all([
    prisma.nAEBReport.findMany({
      where,
      skip,
      take: pagination.limit,
      orderBy: {
        createdAt: 'desc',
      },
      include: {
        generatedByUser: {
          select: {
            id: true,
            name: true,
            email: true,
          },
        },
      },
    }),
    prisma.nAEBReport.count({ where }),
  ]);

  return createPaginationResult(reports, total, pagination.page, pagination.limit);
};

/**
 * Update report
 */
export const updateReport = async (id: string, data: UpdateReportData) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const existing = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!existing) {
    throw new NotFoundError('Report not found');
  }

  // Cannot update submitted or approved reports
  if (existing.status === 'submitted' || existing.status === 'approved') {
    throw new ValidationError('Cannot update submitted or approved reports');
  }

  const updateData: Record<string, unknown> = {
    updatedAt: new Date(),
  };

  if (data.reportType !== undefined) {
    updateData.reportType = data.reportType;
  }

  if (data.periodStart !== undefined) {
    const periodStart = parseDate(data.periodStart);
    if (!periodStart) {
      throw new ValidationError('Valid period start date is required');
    }
    updateData.periodStart = periodStart;
  }

  if (data.periodEnd !== undefined) {
    const periodEnd = parseDate(data.periodEnd);
    if (!periodEnd) {
      throw new ValidationError('Valid period end date is required');
    }

    const periodStart = data.periodStart ? parseDate(data.periodStart) : existing.periodStart;
    if (!periodStart) {
      throw new ValidationError('Period start date is required for validation');
    }
    if (periodEnd < periodStart) {
      throw new ValidationError('Period end date must be after period start date');
    }

    updateData.periodEnd = periodEnd;
  }

  if (data.data !== undefined) {
    if (!data.data || typeof data.data !== 'object' || Array.isArray(data.data)) {
      throw new ValidationError('Report data must be a valid object');
    }
    updateData.data = data.data;
  }

  if (data.status !== undefined) {
    updateData.status = data.status;

    // If status is submitted, set submittedAt
    if (data.status === 'submitted' && !existing.submittedAt) {
      updateData.submittedAt = new Date();
    }
  }

  const report = await prisma.nAEBReport.update({
    where: { id },
    data: updateData,
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
          role: true,
        },
      },
    },
  });

  return report;
};

/**
 * Submit report
 */
export const submitReport = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  if (report.status !== 'draft') {
    throw new ValidationError('Only draft reports can be submitted');
  }

  const updated = await prisma.nAEBReport.update({
    where: { id },
    data: {
      status: 'submitted',
      submittedAt: new Date(),
    },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return updated;
};

/**
 * Approve report
 */
export const approveReport = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  if (report.status !== 'submitted') {
    throw new ValidationError('Only submitted reports can be approved');
  }

  const updated = await prisma.nAEBReport.update({
    where: { id },
    data: {
      status: 'approved',
    },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return updated;
};

/**
 * Reject report
 */
export const rejectReport = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  if (report.status !== 'submitted') {
    throw new ValidationError('Only submitted reports can be rejected');
  }

  const updated = await prisma.nAEBReport.update({
    where: { id },
    data: {
      status: 'rejected',
    },
    include: {
      generatedByUser: {
        select: {
          id: true,
          name: true,
          email: true,
        },
      },
    },
  });

  return updated;
};

/**
 * Delete report
 */
export const deleteReport = async (id: string) => {
  if (!id) {
    throw new ValidationError('Report ID is required');
  }

  const report = await prisma.nAEBReport.findUnique({
    where: { id },
  });

  if (!report) {
    throw new NotFoundError('Report not found');
  }

  // Cannot delete submitted or approved reports
  if (report.status === 'submitted' || report.status === 'approved') {
    throw new ValidationError('Cannot delete submitted or approved reports');
  }

  await prisma.nAEBReport.delete({
    where: { id },
  });

  return { message: 'Report deleted successfully' };
};

/**
 * Generate NAEB report
 * Aggregates data from batches, payments, exports, and certificates
 * for the specified period and generates a comprehensive report
 */
export const generateNaebReport = async (params: NaebReportParams) => {
  const periodStart = params.periodStart ? parseDate(params.periodStart) : null;
  const periodEnd = params.periodEnd ? parseDate(params.periodEnd) : null;

  // Build date filter
  const dateFilter: Record<string, unknown> = {};
  if (periodStart && periodEnd) {
    dateFilter.createdAt = {
      gte: periodStart,
      lte: periodEnd,
    };
  } else if (periodStart) {
    dateFilter.createdAt = {
      gte: periodStart,
    };
  } else if (periodEnd) {
    dateFilter.createdAt = {
      lte: periodEnd,
    };
  }

  // Aggregate batch data
  const [coffeeBatches, teaBatches] = await Promise.all([
    prisma.productBatch.findMany({
      where: {
        type: 'coffee',
        ...dateFilter,
        deletedAt: null,
      },
      select: {
        id: true,
        type: true,
        status: true,
        currentStage: true,
        quantity: true,
        originLocation: true,
        region: true,
        createdAt: true,
      },
    }),
    prisma.productBatch.findMany({
      where: {
        type: 'tea',
        ...dateFilter,
        deletedAt: null,
      },
      select: {
        id: true,
        type: true,
        status: true,
        currentStage: true,
        quantity: true,
        originLocation: true,
        region: true,
        createdAt: true,
      },
    }),
  ]);

  // Aggregate payment data
  const payments = await prisma.payment.findMany({
    where: {
      ...dateFilter,
    },
    select: {
      id: true,
      amount: true,
      currency: true,
      paymentType: true,
      status: true,
      paymentDate: true,
    },
  });

  // Aggregate export data
  const exports = await prisma.exportRecord.findMany({
    where: {
      ...dateFilter,
    },
    select: {
      id: true,
      batchId: true,
      buyerName: true,
      shippingMethod: true,
      shippingDate: true,
      createdAt: true,
    },
  });

  // Aggregate certificate data
  const certificates = await prisma.certificate.findMany({
    where: {
      ...dateFilter,
    },
    select: {
      id: true,
      certificateType: true,
      issuedDate: true,
      expiryDate: true,
    },
  });

  // Calculate statistics
  const totalCoffeeBatches = coffeeBatches.length;
  const totalTeaBatches = teaBatches.length;
  const totalBatches = totalCoffeeBatches + totalTeaBatches;
  const totalCoffeeQuantity = coffeeBatches.reduce((sum, batch) => sum + (batch.quantity || 0), 0);
  const totalTeaQuantity = teaBatches.reduce((sum, batch) => sum + (batch.quantity || 0), 0);
  const totalQuantity = totalCoffeeQuantity + totalTeaQuantity;
  const totalPayments = payments.reduce((sum, payment) => {
    if (payment.status === 'completed') {
      return sum + Number(payment.amount);
    }
    return sum;
  }, 0);
  const totalExports = exports.length;
  const totalCertificates = certificates.length;

  // Group by region
  const regionStats: Record<string, { coffee: number; tea: number; batches: number }> = {};
  [...coffeeBatches, ...teaBatches].forEach((batch) => {
    const region = batch.region || 'Unknown';
    if (!regionStats[region]) {
      regionStats[region] = { coffee: 0, tea: 0, batches: 0 };
    }
    regionStats[region].batches += 1;
    if (batch.type === 'coffee') {
      regionStats[region].coffee += batch.quantity || 0;
    } else {
      regionStats[region].tea += batch.quantity || 0;
    }
  });

  // Group by stage
  const stageStats: Record<string, number> = {};
  [...coffeeBatches, ...teaBatches].forEach((batch) => {
    const stage = batch.currentStage || 'unknown';
    stageStats[stage] = (stageStats[stage] || 0) + 1;
  });

  // Build report data
  const reportData = {
    period: {
      start: periodStart?.toISOString() || null,
      end: periodEnd?.toISOString() || null,
    },
    summary: {
      totalBatches,
      totalCoffeeBatches,
      totalTeaBatches,
      totalQuantity: {
        total: totalQuantity,
        coffee: totalCoffeeQuantity,
        tea: totalTeaQuantity,
      },
      totalPayments,
      totalExports,
      totalCertificates,
    },
    byRegion: regionStats,
    byStage: stageStats,
    batches: {
      coffee: coffeeBatches,
      tea: teaBatches,
    },
    payments: payments.map((p) => ({
      id: p.id,
      amount: p.amount,
      currency: p.currency,
      type: p.paymentType,
      status: p.status,
      date: p.paymentDate,
    })),
    exports: exports.map((e) => ({
      id: e.id,
      batchId: e.batchId,
      buyer: e.buyerName,
      shippingMethod: e.shippingMethod,
      shippingDate: e.shippingDate,
    })),
    certificates: certificates.map((c) => ({
      id: c.id,
      type: c.certificateType,
      issuedDate: c.issuedDate,
      expiryDate: c.expiryDate,
    })),
    generatedAt: new Date().toISOString(),
  };

  return reportData;
};
